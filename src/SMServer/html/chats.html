<!DOCTYPE html>
	<head>
		<meta charset="utf-8" />
		<link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?" />
		<title>
			SMServer
		</title>
		<script>
			var new_chats = "";
			/// These next five lines need to remain without value, since they will be changed when swift parses the file.
			var num_texts_to_load;
			var num_chats_to_load;
			var num_photos_to_load;
			var socket_port;
			var debug;
			var subject;

			var printed_texts = 0;
			var printed_chats = 0;
			var printed_photos = 0;

			var has_shown_warning = false;
			var has_shown_camera_roll = false;
			var notifications = false;
			var has_shown_new_warning = false;
			var currently_typing = false;
			var called_typing_wait = false;
			var shown_ws_alert = false;

			var items = "";
			var new_items = "";
			var shown_name = "";
			var texts = "";
			var image_string = "";
			var current_chat_id = "";
			var typing_sleep = 10000;
			var load_icon = '<i class="fas fa-chevron-circle-up"></i>';
			var fa_icons = ['<i class="fas fa-heart"></i>', '<i class="fas fa-thumbs-up"></i>', '<i class="fas fa-thumbs-down"></i>', '<i class="fas fa-grin-tears"></i>', '<i class="fas fa-exclamation"></i><i class="fas fa-exclamation"></i>', '<i class="fas fa-question"></i>'];
			var taps_to_print = [];

			var doc_url = window.location.href.split("/")[2].split(":")[0];
			var socket_address = doc_url;
			var prefix = "";

			if (doc_url === "127.0.0.1" || doc_url === "localhost") { /// when I'm debugging on local computer
				prefix = "http://192.168.0.180:8741";
				num_texts_to_load = 100;
				num_chats_to_load = 60;
				num_photos_to_load = 40;
				socket_port = 8740;
				socket_address = prefix.split("/")[2].split(":")[0];
				debug = true;
				subject = false;
				document.getElementById("sendform").setAttribute("action", `${prefix}/send`);
			}

			function timeConverter(t, ts_only = false, apple = true, rev = false) {
				if (apple) var ts = (t / 1000000000) + 978307200;
				else var ts = t;
				if (ts_only) {
					if (rev) return (t - 978307200) * 1000000000;
					return ts;
				}

				var a = new Date(ts * 1000);
				var months = ['Jan','Feb','Mar','Apr','May','Jun','Jul','Aug','Sep','Oct','Nov','Dec'];
				var year = a.getFullYear();
				var month = months[a.getMonth()];
				var date = a.getDate();
				var hour = a.getHours();
				var min = a.getMinutes();
				var time = `${date} ${month} ${year} ${hour < 10 ? '0' : ''}${hour}:${min < 10 ? '0' : ''}${min}`;
				return time;
			}

			async function getTextFromURL(url) {
				if (debug) console.log(`getting text from url ${url}`);
				var return_text = "";
				await fetch(url).then(response => response.text())
				.then((response) => {
					return_text = response;
				})
				.catch(error => {
					if (!has_shown_warning) alert(`The server restarted, you need to reload and re-authenticate. url: ${url}`);
					has_shown_warning = true;
				})

				return return_text;
			}

			async function fetchFromURL(url) {
				if (debug) console.log(`fetching url ${url}`);
				var ret = "";
				await fetch(url).then(response => {
					if (!response.ok) throw new Error(`HTTP error ${response.status}`);
					ret = response.json();
				})
				.catch(error => {
					if (!has_shown_warning) alert(`The server restarted, you need to reload and re-authenticate. url: ${url}`);
					has_shown_warning = true;
				})

				return ret;
			}

			function getTextElement(text) {
				if (debug) console.log(`Getting text element for text ${text}`);

				if (Number(text.associated_message_type) < 2000 || text.associated_message_type === undefined) {

					var t = document.createElement("span");
					var rets = [];

					var classes = "text";
					classes += `${text.is_from_me === "0" ? " is_from_them" : " is_from_me"} ${text.service}`;

					t.className = classes;
					t.id = text.guid;
					t.setAttribute("title", timeConverter(text.date));
					t.setAttribute("date_read", text.date_read);
					t.setAttribute("date", text.date);
					t.innerHTML = "";
					t.setAttribute("onclick", `showTapbackDialog("${text.guid}");`);

					/// it's a rich link
					if (text.balloon_bundle_id === "com.apple.messages.URLBalloonProvider" && text.attachments.length > 0) {
						t.className += " noPadding richLink";

						var img = document.createElement("img");
						img.src = `${prefix}/data?path=${text.attachments.length > 1 ? text.attachments[1].filename : text.attachments[0].filename}`;

						var under = document.createElement("a");
						under.href = (text.text.match(/^https{0,1}:\/\//) ? "" : "http://") + text.text;
						under.className = "richLinkUnder";

						if (text.attachments.length > 1) {
							t.appendChild(img);
							t.appendChild(document.createElement("br"));
						} else {
							under.appendChild(img);
							under.classList.add("richLinkSmall");
						}

						var desc = document.createElement("div");
						desc.className = "richLinkDescription";

						var title = document.createElement("p");
						title.innerText = text.link_title;
						title.className = "richLinkTitle";
						desc.appendChild(title);

						if (text.attachments.length > 1) {
							var subtitle = document.createElement("div");
							subtitle.innerText = text.link_subtitle;
							subtitle.className = "richLinkSubtitle";
							desc.appendChild(subtitle);
						}

						under.appendChild(desc);

						if (text.link_type !== undefined && text.link_type.split(".")[0] === "music") {
							var icon = document.createElement("div");
							icon.className = "richLinkIcon";

							var ii = document.createElement("img");
							ii.src = `${prefix}/data?path=${text.attachments[0].filename}`;
							icon.appendChild(ii);
							under.appendChild(icon);
						}

						t.appendChild(under);
						return t;
					}

					if (text.hasOwnProperty("attachments") && text.attachments.length > 0) {

						for (var l = 0; l < text.attachments.length; ++l) {
							var c = t.cloneNode();
							if (l !== 0) c.id += `-${String(l)}`;
							var bigType = text.attachments[l].mime_type.split("/")[0];
							var smallType = text.attachments[l].mime_type.split("/")[1];

							if (bigType === "image") {
								c.innerHTML = `<img src="${prefix}/data?path=${text.attachments[l].filename}"><br>`;
							} else if (bigType === "video") {
								c.innerHTML = `<video controls="controls" src="${prefix}/data?path=${text.attachments[l].filename}"></video>`;
							} else if (bigType === "audio") {
								c.innerHTML = `<audio controls="controls" src="${prefix}/data?path=${text.attachments[l].filename}"></audio>`;
							} else if (text.attachments[l].length !== 0){
								var splits = text.attachments[l].filename.split("/");
								var link = document.createElement("a");
								link.href = `${prefix}/data?path=${text.attachments[l].filename.replace(/ /g, "%20")}`;
								link.setAttribute("mime_type", text.attachments[l].mime_type);
								link.className = "inlineAttachment";

								var fa = "file";

								if (text.attachments[l].mime_type.length > 0 && smallType !== undefined) {
									var dict = {'pdf': 'file-pdf', 'vcard': 'id-card', 'x-debian-package': 'archive', 'x-sh': 'file-code', 'zip': 'file-archive', 'x-python-script': 'file-code'};
									if (dict[smallType] !== undefined) fa = dict[smallType];
								}

								var icon = `<i class="fas fa-${fa}"></i>`;

								link.innerHTML = `${icon} <span>${splits[splits.length - 1]}</span>`;
								c.innerHTML += link.outerHTML;
							}
							if (bigType === "image" || bigType === "video" || bigType === "audio")
								c.className += " noPadding fullAttachment";
							rets.push(c);
						}
					}

					if (text.text.replace(/￼/g, "").trim().length > 0 || text.subject.length > 0) {
						/// There's an invisible character between those first two quotes that sometimes displays on firefox. This just removes it
						if (text.subject.length > 0) {
							var subject = document.createElement("div");
							subject.className = "subject";
							subject.innerText = text.subject;
							t.appendChild(subject);
						}

						var inner = document.createElement("span");
						inner.innerText += text.text.replace(/￼/g, "");
						t.appendChild(inner);
					}

					var emoji_check = text.text.match(/\p{Extended_Pictographic}/gu);
					if (text.subject === "" && emoji_check !== null && emoji_check.join("").length === text.text.length)
						t.classList.add("allEmoji");

					rets.push(t);
					return rets;
				} else if (Number(text.associated_message_type) < 2006 && Number(text.associated_message_type) > 1999) {
					var guid = text.associated_message_guid.slice(-36);

					var original = document.getElementById(guid);

					if (original === null || original === undefined) return document.createElement("span");

					var tap = document.createElement("span");
					tap.className = `tapback ${text.is_from_me === "1" ? "tapFromMe" : "tapFromThem"}`;
					tap.setAttribute("tapbackType", String(Number(text.associated_message_type) - 2000));
					tap.setAttribute("sender", text.sender);

					tap.innerHTML = fa_icons[Number(text.associated_message_type) - 2000];

					var elder = original.parentNode;
					if (elder.className.includes("text-area")) {
						var ln = elder.getElementsByClassName("tapback").length;
						var mg = ` -${ln * 2}6px;`;
						mg += `z-index: ${9 < (ln + 2) ? 9 : (ln + 2)};`;
						if (elder.className.includes("from_them")) {
							tap.setAttribute("style", `left:${mg}`);
							elder.appendChild(tap);
						} else {
							tap.setAttribute("style", `right:${mg}`);
							elder.insertBefore(tap, elder.firstChild);
						}
					} else {
						var next = original.nextElementSibling;
						var copy = original.cloneNode(true);

						var area = document.createElement("span");
						var new_class = "text-area";
						new_class += copy.className.includes("is_from_them") ? " from_them" : " from_me";
						area.className = new_class;

						if (copy.className.includes("is_from_them")) {
							area.appendChild(copy);
							area.appendChild(tap);
						} else {
							area.appendChild(tap);
							area.appendChild(copy);
						}

						original.outerHTML = area.outerHTML;
					}

				} else if (Number(text.associated_message_type) > 2999 && Number(text.associated_message_type) < 3006) {
					var guid = text.associated_message_guid.split("/")[1];
					var box = document.getElementById(guid)
					if (box !== null) {
						var area = box.parentNode;

						for (var i = 0; i < area.children.length; i++) {
							if (Number(area.children[i].getAttribute("tapbackType")) + 1000 === Number(text.associated_message_type)) {
								area.children[i].outerHTML = "";
								break;
							}
						}
					}
				}

				return document.createElement("span");
			}

			function getChatElement(chat, num_texts, searched = false, relevant_text = 0) {
				/// relevant_text will contain the ROWID of the matching text from the search
				if (debug) console.log(`Getting chat element for ${chat.chat_identifier}, num: ${num_texts}`);
				var b = document.createElement("button");

				if (!searched) b.id = chat.chat_identifier;
				else b.setAttribute("chat_id", chat.chat_identifier);

				b.setAttribute("addresses", (chat.addresses !== undefined && chat.addresses !== "" ? chat.addresses : chat.chat_identifier));

				var i = document.createElement("span");

				var cimg = document.createElement("img");
				cimg.src = `${prefix}/data?chat_id=${chat.chat_identifier}`
				cimg.setAttribute("onerror", `javascript:setProfileImageAsText("${chat.chat_identifier}");`);
				i.appendChild(cimg);

				var classes = chat.has_unread === "true" ? "unread" : "";

				var n = document.createElement("div");
				n.className = "chat-name";

				var sp = document.createElement("span");
				sp.innerText = chat.display_name.length === 0 ? chat.chat_identifier : chat.display_name;
				n.appendChild(sp);

				if (chat.pinned === "false") {
					b.appendChild(i);

					var nonpic = document.createElement("div");
					nonpic.className = "chat-nonpic";

					var top = document.createElement("div");
					top.className = "chat-toprow";

					if (chat.chat_identifier.substring(0, 4) !== "chat" && !chat.chat_identifier.includes("@") && chat.display_name.length !== 0)
						n.innerHTML += `<span style="color: #858585; font-weight: 200;"> (${chat.chat_identifier})</span>`;

					top.appendChild(n);

					var d = document.createElement("div");
					d.className = "chat-date";
					d.innerText = chat.relative_time;
					top.appendChild(d);
					nonpic.appendChild(top);

					var t = document.createElement("div");
					t.className = "chat-text";
					t.innerText = chat.latest_text.replace(/￼/g, "");
					nonpic.appendChild(t);
					b.appendChild(nonpic);

					classes += " unpinned";
				} else {
					var t = document.createElement("div");
					t.className = "chat-top";
					t.appendChild(i);

					if (chat.has_unread === "true") {
						var ct = document.createElement("div");
						ct.className = "chat-text";
						ct.innerText = chat.latest_text.replace(/￼/g, "");

						t.appendChild(ct);
					}

					b.appendChild(t);
					b.appendChild(n);
					classes += " pinned";
				}

				b.className = classes;

				var gts = `getTexts("${chat.chat_identifier}", ${num_texts}` + (chat.addresses !== undefined ? `, "${chat.addresses}"` : "") + ');';
				b.setAttribute("onclick", gts);

				return b;
			}

			function setProfileImageAsText(chat_id, is_title = false) {
				if (debug) console.log(`settings profile image for ${chat_id} as text, is_title: ${is_title}`);
				var c = document.querySelector(`[addresses*="${chat_id}"]`);
				var im = is_title ? document.getElementById("messagesTitleText").firstChild : c.querySelector("img");
				var dn = c.getElementsByClassName("chat-name")[0].firstChild.innerText;

				var i = document.createElement("span");
				i.className = "chat-image";

				var cil = document.createElement("span");
				cil.className = "chat-image-letters";

				var name_split = dn.replace(/\p{Extended_Pictographic}/gu, "").split(" ");
				cil.innerText = `${name_split[0].substr(0, 1)}${name_split.length > 1 ? name_split[name_split.length - 1].substr(0, 1) : ""}`;
				i.appendChild(cil);

				im.outerHTML = i.outerHTML;
				console.log("Don't worry about these 404 errors, they're expected and handled :)");
			}

			function printListOfTexts(texts, append = true, is_group = false) {
				/// If append is true, then it places this list of texts under the existing ones. Else, it places them above the existing ones.
				/// the Last element in `texts` will always be the farthest from the texts that were here when this was called
				/// Also this function is a nightmare; if something is going terribly wrong it may be easier to just rewrite it than troubleshoot
				if (debug) console.log(`printing List of texts ${texts.length}, appending: ${append}`);

				var tc = document.getElementById("text-content");
				var et = document.getElementsByClassName("text");
				var orig_len = et.length;
				var printed = false;

				var spacer = document.createElement("div");
				spacer.className = "spacer";

				var lnr = texts.length - 1 /// lnr = last non-reaction text
				for (; lnr > 0 && texts[lnr].associated_message_type !== "0"; lnr--) {}

				for (var i = 0; i < texts.length; i++) {
					if (Number(texts[i].associated_message_type) > 1999 && Number(texts[i].associated_message_type) < 3006) {
						taps_to_print.push(texts[i]);
						continue;
					}

					var fts = getTextElement(texts[i]);
					if (fts.length === undefined && fts.outerHTML === "<span></span>") continue;
					var ft = fts.length === undefined ? [fts] : fts;
					if (ft.length === 0) continue;

					printed = true;

					if (!append) ft.reverse();

					var ld = i > 0 ? texts[i-1].date : 0;
					var notLast = false;
					var n = append ? i+1 : i-1;

					var sender_box = document.createElement("div");
					sender_box.className = "sender";

					var add_spacer = false;
					var append_time_display = false;
					var hourBreak = false;
					var tenMinuteBreak = false;

					if (i === 0 && et.length > 0) {
						if (append) {
							tenMinuteBreak = texts[i].date - et[et.length-1].getAttribute("date") >= 600000000000;
							var sameSender = (et[et.length-1].className.includes("from_me") && texts[i].is_from_me === "1") || (et[et.length-1].className.includes("from_them") && texts[i].is_from_me === "0");
							if (is_group && sameSender) {
								var senders = document.getElementsByClassName("sender");
								sameSender = senders[senders.length-1].firstChild.textContent === texts[i].sender;
							}
							if (!tenMinuteBreak && sameSender)
								et[et.length-1].classList.add("notLast");
							else if (texts[i].date - et[et.length-1].getAttribute("date") >= 3600000000000)
								append_time_display = true;
							else if (is_group && !sameSender)
								sender_box.innerText = texts[i].sender;
						} else {
							var hourTillFirst = texts[i].date - et[0].getAttribute("date") >= 3600000000000;
							if (!hourTillFirst) document.getElementsByClassName("time-display")[0].outerHTML = "";
						}
					}

					if ((append && i < texts.length - 1) || (!append && i > 0)) {
						var brk = append ? 1 : -1;
						for (; (append ? n < texts.length : n >= 0) && texts[n].associated_message_type !== "0"; n += brk) {}

						if ((append && n < texts.length) || (!append && n >= 0)) {
							tenMinuteBreak = texts[n].date - texts[i].date >= 600000000000;
							hourBreak = texts[n].date - texts[i].date >= 3600000000000;
							if (!hourBreak && texts[i].is_from_me === texts[n].is_from_me && (!is_group || texts[i].sender === texts[n].sender)) {
								if (tenMinuteBreak) add_spacer = true;
								else notLast = true;
							}

							if (is_group && texts[n].is_from_me === "0" && texts[i].sender !== texts[n].sender)
								sender_box.innerText = texts[n].sender;
						}
					}

					if (append_time_display || (i === 0 && append && orig_len === 0))
						tc.innerHTML += `<div class="time-display"><p>${timeConverter(texts[i].date)}</p></div>`;

					for (var j = 0; j < ft.length; j++) {
						if (ft[j].innerHTML === undefined || ft[j].innerHTML === "") continue;
						if (notLast || (append && j < ft.length - 1) || (!append && j > 0)) ft[j].classList.add("notLast");
						if (append) tc.appendChild(ft[j]);
						else tc.insertBefore(ft[j], document.getElementById("moretextsbutton").nextSibling);
					}

					var orig = null; /// if you do insertBefore(node, null), it just appends.
					if (!append) {
						orig = document.getElementById(ft[0].id);
						while (orig !== null && orig !== undefined && orig.id === ft[0].id) orig = orig.nextSibling;
					}

					if (add_spacer)
						tc.insertBefore(spacer, append ? null : tc.firstChild.nextSibling);

					if ((hourBreak && i < texts.length - 1) || (!append && i === lnr) || (append && i === 0 && orig_len == 0)) {
						if (hourBreak || !append) {
							var td = document.createElement("div");
							td.className = "time-display";
							td.innerHTML = `<p>${timeConverter(texts[n].date)}</p>`;

							if (append || i < lnr) tc.insertBefore(td, orig);
							else tc.insertBefore(td, tc.firstChild.nextSibling);
						}

						if (is_group) {
							var tds = document.getElementsByClassName("time-display");
							if (n < texts.length && texts[n].is_from_me === "0") {
								sender_box.innerText = texts[n].sender;
								var next = texts[n].sender === texts[i].sender ? tds[0].nextSibling : orig;
								if (append && i !== 0) next = tds[tds.length - 1].nextSibling;
								tc.insertBefore(sender_box, next);
							} 
							if (((append && i === 0) || (!append && i === lnr)) && texts[i].is_from_me === "0" && (n >= texts.length || texts[i].sender !== texts[n].sender)) {
								var clone = sender_box.cloneNode();
								clone.innerText = texts[i].sender;
								tc.insertBefore(clone, tds[0].nextSibling);
							}
							sender_box = undefined;
						}
					}

					if (sender_box !== undefined && sender_box.innerText != "")
						tc.insertBefore(sender_box, orig);
				}

				if (append && !is_group) {
					et = document.getElementsByClassName("text");

					var rr = document.getElementsByClassName("readreceipt");
					if (rr.length > 0) rr[0].outerHTML = "";
					var lt = undefined;

					for (var i = et.length - 1; i >= 0 && lt === undefined; i--)
						if (et[i].className.includes("from_me") && et[i].className.includes("iMessage") && et[i].getAttribute("date_read") !== "0" && et[i].getAttribute("date_read") !== "undefined")
							lt = et[i];

					if (lt !== undefined) {
						var nrr = document.createElement("span");
						nrr.className = "readreceipt";
						nrr.innerHTML = `<strong>Read</strong> ${timeConverter(parseInt(lt.getAttribute("date_read")))}`;

						if (lt === tc.lastChild) tc.appendChild(nrr);
						else tc.insertBefore(nrr, lt.nextSibling);
					}
				}

				for (var i = 0; i < taps_to_print.length; i++) {
					getTextElement(taps_to_print[i]);
				}

				if (append && printed) tc.lastChild.scrollIntoView();
			}

			function clearTextContent() {
				if (debug) console.log("clearing text content");
				document.getElementById("text-content").innerHTML = '<div class="centered"> Select a chat on the left to view your messages :)</div>';
				printed_texts = 0;
				document.getElementById("messagesTitleText").innerHTML = "";
				document.getElementById("hiddenchatbox").setAttribute("value", "");

				var sels = document.getElementsByClassName("selected");
				for (var i = 0; i < sels.length; i++)
					sels[i].className = sels[i].className.replace(/selected/g, "");

				current_chat_id = "";
			}

			const printChats = async (offset = 0) => {
				if (debug) console.log("printing Chats");
				let url = `${prefix}/requests?chat=0&num_chats=${num_chats_to_load}&chats_offset=${offset}`;
				let chatPromise = await fetchFromURL(url);
				this.items = chatPromise.chats;

				const num_texts = num_texts_to_load;
				var doc = document.getElementsByClassName("chats-list")[0];
				var old_button = document.getElementById("morechatsbutton");

				var selected_id = "";
				var selecteds = document.getElementsByClassName("selected");
				if (selecteds.length > 0) selected_id = selecteds[0].id;

				doc.innerHTML = "";
				doc.appendChild(old_button);

				printed_chats = num_chats_to_load;

				for(var i = 0; i < items.length; i++) {

					var b = getChatElement(items[i], num_texts);

					if (items[i].chat_identifier === selected_id)
						b.classList.add("selected");

					if (b.className.includes("unpinned")) {
						doc.insertBefore(b, document.getElementById("morechatsbutton"));
					} else {
						var pinRows = document.getElementsByClassName("pinRow");

						if (pinRows.length > 0 && pinRows[pinRows.length - 1].children.length < 3) {
							pinRows[pinRows.length - 1].appendChild(b);
						} else {
							var row = document.createElement("div");
							row.className = "pinRow";
							row.appendChild(b);

							if (doc.children.length === 0)
								doc.appendChild(row);
							else if (pinRows.length === 0)
								doc.insertBefore(row, doc.firstChild);
							else if (pinRows.length > 0)
								doc.insertBefore(row, pinRows[pinRows.length - 1].nextSibling);
						}
					}
				}

				var unread_chats = document.getElementsByClassName("unread").length;
				document.title = `SMServer${unread_chats > 0 ? " (" + String(unread_chats) + ")" : ""}`

				console.log("There will probably be a significant amount of 404 errors here, ignore them. They've been handled :)");
			}

			const getMoreChats = async (offset = printed_chats) => {
				if (debug) console.log("getting more chats");
				let url = `${prefix}/requests?chat=0&num_chats=${num_chats_to_load}&chats_offset=${offset}`;
				let chatsPromise = await fetchFromURL(url);
				new_items = chatsPromise.chats;

				printed_chats += num_chats_to_load;
				var doc = document.getElementsByClassName("chats-list")[0];

				for(var i = 0; i < new_items.length; i++) {
					var b = getChatElement(new_items[i], num_texts_to_load);
					doc.insertBefore(b, document.getElementById("morechatsbutton"));
				}

				console.log("There will probably be a significant amount of 404 errors here, ignore them. They've been handled :)");
			}

			const getTexts = async (chat_id, num_texts, addresses = "") => {
				if (debug) console.log(`getting ${num_texts} for chat ${chat_id}`);

				var myNode = document.getElementsByClassName("text-content")[0];

				var selected = document.getElementsByClassName("selected");
				if (selected.length > 0)
					selected[0].className = selected[0].className.replace(/selected/g, "");

				var hiddenchatbox = document.getElementById("hiddenchatbox");
				hiddenchatbox.setAttribute("value", chat_id);

				var orig_btn = document.querySelector(`[addresses*="${chat_id}"]`);
				orig_btn.className = orig_btn.className.replace(/unread/g, "") + " selected";
				var unread_chats = document.getElementsByClassName("unread").length;
				document.title = `SMServer${unread_chats > 0 ? " (" + String(unread_chats) + ")" : ""}`;

				if (!orig_btn.className.includes("unpinned") && orig_btn.getElementsByClassName("chat-text").length > 0)
					orig_btn.getElementsByClassName("chat-text")[0].outerHTML = "";

				var chat_title = orig_btn.getElementsByClassName("chat-name")[0];
				var title_doc = document.getElementsByClassName("title-content")[0];
				if (chat_title.children.length > 0) title_doc.innerHTML = `<p>${chat_title.firstChild.textContent}</p>`;
				else title_doc.innerHTML = `<p>${chat_title.textContent}</p>`;

				current_chat_id = chat_id;

				var img = document.createElement("img");
				img.src = `${prefix}/data?chat_id=${chat_id}`;
				img.setAttribute("onerror", `javascript:setProfileImageAsText("${chat_id}", true);`);

				title_doc.insertBefore(img, title_doc.firstChild);

				let url = `${prefix}/requests?person=${addresses === "" ? chat_id : addresses}&num=${num_texts}`;

				let textsPromise = await fetchFromURL(url);
				this.texts = textsPromise.texts;

				myNode.innerHTML = "";

				var more = document.createElement("button");
				more.setAttribute("onclick", "getMoreTexts()");
				more.id = "moretextsbutton";
				more.innerHTML = '<i class="fas fa-chevron-circle-up"></i> More';
				myNode.appendChild(more);

				printed_texts = texts.length;
				texts = texts.reverse();

				var is_group = chat_id.substring(0, 4) === "chat" && !chat_id.includes("@");
				printListOfTexts(texts, true, is_group);

				document.getElementById("text-content").lastChild.scrollIntoView();
				document.getElementById("sendbox").focus();

				if (texts.length < num_texts) document.getElementById("moretextsbutton").outerHTML = "";
			}

			const getMoreTexts = async (num_texts = num_texts_to_load) => {
				if (debug) console.log(`called getMoreText; num === ${num_texts}`);
				var chat_id = document.querySelector(`[addresses*="${current_chat_id}"]`).getAttribute("addresses");

				let url = `${prefix}/requests?person=${chat_id}&num=${num_texts_to_load}"&offset=${printed_texts}&read=false`;
				let textPromise = await fetchFromURL(url);
				this.texts = textPromise.texts;

				printed_texts += texts.length;

				var is_group = chat_id.substring(0, 4) === "chat";
				printListOfTexts(texts, false, is_group);

				if (texts.length < num_texts) document.getElementById("moretextsbutton").outerHTML = "";
			}

			function sleep(ms) {
				return new Promise(resolve => setTimeout(resolve, ms));
			}

			async function sendForm() {
				if (debug) console.log("sending form");
				if (current_chat_id.length === 0) return;

				var form = document.getElementById("sendform");

				typing_sleep = 0;

				var tbox = document.getElementById("sendbox");
				var oldval = tbox.value;
				var gpval = document.getElementById("hiddenchatbox").value;
				var is_group = gpval.substring(0, 4) === "chat" && !gpval.includes("@");

				var photos = document.getElementById("hiddenphotobutton");
				var selected = document.getElementsByClassName("selected-photo");
				for (var i = 0; i < selected.length; ++i) {
					photos.value += selected[i].id + (i !== selected.length - 1 ? ":" : "");
				}

				var total_size = 0;
				var files = document.getElementById("attachmentbutton").files;
				for (var i = 0; i < files.length; i++) {
					total_size += files[i].size;
				}

				var submit = (oldval.length > 0 || selected.length > 0 || document.getElementById("attachmentbutton").files.length > 0);
				var has_attachments = (selected.length > 0 || document.getElementById("attachmentbutton").files.length > 0);

				if (submit) {
					form.submit();

					tbox.value = "";
					var subval = "";
					if (subject) {
						subval = document.getElementById("subjectBox").value;
						document.getElementById("subjectBox").value = "";
					}

					document.getElementById("attachmentbutton").value = "";
					document.getElementById("unhiddenbutton").innerHTML = '<i class="fas fa-paperclip"></i>';
					hideCameraRoll(); /// Since it changes the photo button value and unselects all the currently selected photos
					photos.value = "";

					autoGrow();
				}
			}

			async function sendComposeForm() {
				if (debug) console.log("sending Compose form");
				hidePopup();

				var form = document.getElementById("composeform");
				var tbox = document.getElementById("composeSendBox");
				var oldval = tbox.value;

				var hta = document.getElementById("hiddenComposeTextArea");
				hta.value = oldval;

				var cbox = document.getElementById("composeAddressBox");
				var coldval = cbox.value;
				cbox.value = coldval;

				form.submit();

				setChatAsTop(coldval, oldval);

				await sleep(500);

				tbox.value = "";
				hta.value = "";
				cbox.value = "";
				document.getElementById("composeShowingAttachmentButton").value = "";
				document.getElementById("composeAttachmentButton").value = "";
			}

			function inputKeyDown(subject = false) {
				if (!subject) autoGrow();
				if (current_chat_id !== "") {
					if (document.getElementById("sendbox").value.length > 0) {
						typing_sleep = 10000;
						if (!currently_typing) socket.send(`typing:${current_chat_id}`);
						currently_typing = true;
						typingWait();
					} else {
						typing_sleep = 0;
					}
				}
			}

			async function typingWait() {
				if (!called_typing_wait) {
					called_typing_wait = true;
					while (typing_sleep > 0) {
						typing_sleep -= 200;
						await sleep(200);
					}
					if (currently_typing) {
						currently_typing = false;
						socket.send(`idle:${current_chat_id}`);
					}
					called_typing_wait = false;
				}
			}

			async function autoGrow() {
				var elem = document.getElementById("sendbox");
				var oldheight = elem.style.height.match(/\d/g);
				elem.style.height = getComputedStyle(document.documentElement).getPropertyValue("--send-button-size");
				var scroll_height = elem.scrollHeight;
				elem.style.height = scroll_height + "px";

				/// I don't know why this next section is necessary but it is
				if (elem.value === "" || (oldheight !== null && Number(oldheight.join("")) > scroll_height)) {
					var uhb = document.getElementById("unhiddenbutton");
					var crb = document.getElementById("camerarollbutton");

					await uhb.setAttribute("style", "margin: 0 !important;");
					await crb.setAttribute("style", "margin: 0 !important;");
					await sleep(1); /// Why do I need this. so dumb
					await uhb.setAttribute("style", "margin: auto 0;");
					await crb.setAttribute("style", "margin: auto 0;");
				}
			}

			function showPopup() {
				document.getElementById("popup").style.display = "block";

				if (!has_shown_new_warning) {
					alert("IMPORTANT: When using the compose box, you must type in the full phone number of the recipient, including a plus sign (+) before the country code. See hint for example.");
					self.has_shown_new_warning = true;
				}
			}

			function hidePopup() {
				document.getElementById("popup").style.display = "none";
			}

			function parseMessage(msg) {
				if (debug) console.log(`parsing message ${msg}`);
				var split = msg.split(":");

				var prefix = split[0];
				var content = "";
				if (split.length > 0) content = msg.replace(prefix + ":", "");

				switch (prefix) {
					case "text":
						processNewText(content);
						break;
					case "battery":
						setNewBatteryLevel(content);
						break;
					case "typing":
						setChatAsTyping(content);
						break;
					default:
						console.log(`cannot handle request: '${msg}'`);
						break;
				}
			}

			async function processNewText(text) {
				if (debug) console.log(`received new text: ${text}`);

				var notif_text = JSON.parse(text).text;
				var new_text = notif_text.text;
				var chat = notif_text.chat_identifier;

				var btn = document.querySelector(`[addresses*="${chat}"]`);

				var name = "";

				if (notif_text.is_from_me === "0") {
					if (notif_text.text.replace(/￼/g, "").trim() === "" && notif_text.cache_has_attachments === "1")
						new_text = `Attachment: ${notif_text.attachments[0].mime_type.split("/")[0]}`;

					if (notif_text.sender !== undefined && notif_text.sender !== "nil") {
						name = notif_text.sender;
						new_text = `${notif_text.sender}: ${new_text}`;
					}

					if (window.Notification && Notification.permission === "granted" && (!document.hasFocus() || chat !== current_chat_id)) {
						if (name === "") name = await getTextFromURL(`${prefix}/requests?name=${chat}`);
						var n = new Notification(name, { body: new_text, icon: "/favicon.ico"});
					}
				}

				if (chat.length !== 0) {
					if (btn === undefined || btn === null || chat === "any") {
						printChats();
					} else if (chat !== document.getElementsByClassName("unpinned")[0].id && btn.className.includes("unpinned")) {
						setChatAsTop(chat, new_text);
					} else {

						if (chat !== current_chat_id || !document.hasFocus()) btn.classList.add("unread");
						if (btn.className.includes("unpinned") || btn.getElementsByClassName("chat-text")[0] !== undefined) {

							var text = btn.getElementsByClassName("chat-text")[0];
							if (text !== undefined && new_text.length > 0) text.innerText = new_text;
						} else if (chat !== current_chat_id) {
							var text = document.createElement("div");
							text.className = "chat-text";
							text.innerText = new_text;

							var tb = btn.getElementsByClassName("chat-top")[0];
							tb.appendChild(text);
						}

					}

					if (chat === current_chat_id) {
						var typ = document.getElementById("typingIndicator");
						var typing_outer = "";
						if (typ !== undefined && typ !== null) {
							if (notif_text.is_from_me === "1") typing_outer = typ.outerHTML;
							typ.outerHTML = "";
						}
						printListOfTexts([notif_text], true, notif_text.room_name.length > 0);
						if (typing_outer !== "") document.getElementById("text-content").innerHTML += typing_outer;
					}
				}

				var unread_chats = document.getElementsByClassName("unread").length;
				document.title = `SMServer${unread_chats > 0 ? " (" + String(unread_chats) + ")" : ""}`;
			}

			async function setChatAsTop(chat, new_text = "") {
				if (debug) console.log(`Setting chat as top: ${chat}, new: ${new_text}`);

				var chatsList = document.getElementsByClassName("chats-list")[0];
				var unpins = document.getElementsByClassName("unpinned");
				var current_box = document.querySelector(`[addresses*="${chat}"]`);

				if ((current_box && !current_box.className.includes("unpinned")) || (unpins.length > 0 && chat === unpins[0].id)) {
					if (new_text !== "" && current_box.className.includes("unpinned"))
						current_box.getElementsByClassName("chat-text")[0].innerText = new_text;

					if (!document.hasFocus() || current_chat_id !== chat)
						current_box.classList.add("unread");
				} else {
					var last_text;
					var selected = false;
					/// The most recent text from this person has (nearly) all the info we need
					var url = `${prefix}/requests?person=${chat}&num=1&read=false`;
					let textPromise = await fetchFromURL(url);
					last_text = textPromise.texts[0];

					var new_chat = {
						'time_marker': last_text.date,
						'pinned': 'false',
						'latest_text': new_text.length > 0 ? new_text : last_text.text,
						'chat_identifier': chat,
						'display_name': chat,
						'has_unread': 'false',
						'relative_time': 'now',
					}

					var existingButton = document.querySelector(`[addresses*="${chat}"]`);
					if (existingButton) {
						new_chat.pinned = existingButton.className.includes("unpinned") ? "false" : "true";
						new_chat.display_name = existingButton.getElementsByClassName("chat-name")[0].firstChild.textContent;
						selected = existingButton.className.includes("selected");
						existingButton.outerHTML = "";
					} else {
						new_chat.display_name = await getTextFromURL(`${prefix}/requests?name=${chat}`);
					}

					var new_box = getChatElement(new_chat);
					if (selected) new_box.classList.add("selected");

					var pinRows = document.getElementsByClassName("pinRow");

					if (pinRows.length === 0)
						chatsList.insertBefore(new_box, chatsList.firstChild);
					else
						chatsList.insertBefore(new_box, pinRows[pinRows.length - 1].nextSibling);
				}

			}

			function setSelectedPhoto(url) {
				if (debug) console.log(`setting selected photo for ${url}`);
				var p = document.getElementById(url);
				if (p.className.includes("selected-photo"))
					p.className = "photo";
				else
					p.classList.add("selected-photo");
			}

			function getPhotoElement(photo) {
				if (debug) console.log(`Getting photo element ${photo}`);
				var p = document.createElement("span");

				var c = "photo";
				if (photo.is_favorite === "true") c += " is_favorite";

				p.className = c;

				p.id = photo.URL;
				p.setAttribute("onclick", `setSelectedPhoto("${photo.URL}");`);
				p.setAttribute("width", "160");
				p.setAttribute("height", "160");

				p.innerHTML = `<img src="${prefix}/data?photo=${photo.URL}">`;

				if (photo.is_favorite === "true") {
					var h = document.createElement("span");
					h.className = "favorite-heart";
					h.innerHTML = '<i class="fas fa-heart"></i>';
					p.appendChild(h);
				}
				return p;
			}

			async function displayCameraRoll() {
				if (debug) console.log("Displaying camera roll");
				document.getElementById("camerarollpopup").style.display = "block";

				var cr = document.getElementById("camerarollContent");

				if (!has_shown_camera_roll) {
					var photos;

					var url = `${prefix}/requests?photos=${num_photos_to_load}`;
					let photoPromise = await fetchFromURL(url);
					photos = photoPromise.photos;
					if (photos.length === 0) {
						let photoPromise = await fetchFromURL(url);
						photos = photoPromise.photos;
					}

					printed_photos += photos.length;

					for (var i = 0; i < photos.length; i++) {
						var p = await getPhotoElement(photos[i]);

						cr.insertBefore(p, cr.children[cr.children.length - 1]); /// I should just do cr.lastChild but it doesn't work
					}
					has_shown_camera_roll = true;
				}
			}

			async function loadMoreCameraRoll() {
				if (debug) console.log("loading more Camera Roll");
				var cr = document.getElementById("camerarollContent");
				var new_photos;

				var url = `${prefix}/requests?photos=${num_photos_to_load}&photo_offset=${printed_photos}`;
				let photoPromise = await fetchFromURL(url);
				new_photos = photoPromise.photos;
				printed_photos += new_photos.length;

				for (var i = 0; i < new_photos.length; i++) {
					var p = await getPhotoElement(new_photos[i]);
					cr.insertBefore(p, cr.children[cr.children.length - 1]);
				}
			}

			function hideCameraRoll() {
				if (debug) console.log("hiding camera roll");
				document.getElementById("camerarollpopup").style.display = "none";
				var p = document.getElementsByClassName("selected-photo");

				for (var i = p.length - 1; i >= 0; --i)
					p[i].className = p[i].className.replace(/selected-photo/g, "");

				document.getElementById("camerarollbutton").innerHTML = '<i class="fas fa-camera"></i>';
			}

			function selectCameraRollPhotos() {
				if (debug) console.log("selecing camera roll photos");
				document.getElementById("camerarollpopup").style.display = "none";
				document.getElementById("camerarollbutton").innerHTML = document.getElementsByClassName("selected-photo").length;
			}

			function setNewBatteryLevel(level) {
				if (debug) console.log(`new battery level: ${level}`);
				var batt = document.getElementById("battery");
				var bat_symbol = document.getElementById("batterySymbol");

				var symbol = "";
				if (isNaN(level)) {

					if (level === "charging")
						symbol = ' <i id="chargingSymbol" class="fas fa-bolt"></i>';

					var cgs = document.getElementById("chargingSymbol");
					if (cgs !== undefined && cgs !== null)
						cgs.outerHTML = symbol;
					else
						bat_symbol.innerHTML = symbol + bat_symbol.innerHTML;

				} else {
					var dbl = ~~Number(level);

					if (dbl < 5)
						symbol = ' <i id="levelSymbol" class="fas fa-battery-empty"></i>';
					else if (dbl < 25)
						symbol = ' <i id="levelSymbol" class="fas fa-battery-quarter"></i>';
					else if (dbl < 50)
						symbol = ' <i id="levelSymbol" class="fas fa-battery-half"></i>';
					else if (dbl < 75)
						symbol = ' <i id="levelSymbol" class="fas fa-battery-three-quarters"></i>';
					else
						symbol = ' <i id="levelSymbol" class="fas fa-battery-full"></i>';

					var lvs = document.getElementById("levelSymbol");
					if (lvs !== undefined && lvs !== null)
						lvs.outerHTML = symbol;
					else
						bat_symbol.innerHTML = bat_symbol.innerHTML + symbol;

					batt.innerHTML = `${String(level).split(".")[0]}%${bat_symbol.outerHTML}`;

					if (dbl > 35)
						batt.className = "fullEnough";
					else if (dbl > 20)
						batt.className = "risky";
					else
						batt.className = "low";
				}
			}

			function setChatAsTyping(chat) {
				if (debug) console.log(`setting ${chat} as typing`);
				var current = document.getElementById("typingIndicator");
				if (current !== null && current !== undefined) return;
				if (chat === current_chat_id) {
					var d = document.createElement("div");
					d.className = "text is_from_them iMessage";
					d.id = "typingIndicator";

					d.innerHTML = '<span class="dot flashing">• </span><span class="dot">• </span><span class="dot">•</span>';

					document.getElementById("text-content").appendChild(d);
					d.scrollIntoView();

					var c = 0;
					var typing = window.setInterval(() => {
						var i = document.getElementById("typingIndicator");
						if (i === null) {
							clearInterval(typing);
							return;
						}
						i.children[c].className = "dot";
						c = (c + 1) % 3;
						i.children[c].className = "dot flashing";
					}, 400);
				}
			}

			function enableSubject() {
				if (debug) console.log("enabling subject");
				var tbox = document.getElementById("sendbox");
				var ntbox = tbox.cloneNode(false);
				ntbox.className = "subjectInput";
				ntbox.setAttribute("placeholder", "body");

				var con = document.createElement("div");
				con.className = "subjectTextarea";

				var sbox = document.createElement("textarea");
				sbox.className = "subjectSubject";
				sbox.id = "subjectBox";
				sbox.setAttribute("name", "subject");
				sbox.setAttribute("oninput", "if (event.keyCode !== 13) inputKeyDown(true);");
				sbox.setAttribute("onkeydown", "if (event.keyCode === 13) { document.getElementById('sendbox').focus(); event.preventDefault(); }");
				sbox.setAttribute("form", tbox.getAttribute("form"));
				sbox.setAttribute("placeholder", "Subject");

				con.innerHTML = sbox.outerHTML + ntbox.outerHTML;
				tbox.outerHTML = con.outerHTML;

				document.documentElement.style.setProperty("--messages-send-height", "64px"); /// hardcoded. not a fan. should fix
				document.documentElement.style.setProperty("--send-box-size", "calc((var(--messages-send-height) / 2) - 6px)");
				document.getElementById("sendbutton").className = "hasSubject";

				document.getElementById("camerarollbutton").style.margin = "auto 0";
				document.getElementById("unhiddenbutton").style.margin = "auto 0";
			}

			async function submitSearch() {
				var term = document.getElementById("searchBox").value;
				window.location.href = `${prefix}/requests?search=${term}`; /// uhh simple stuff; use default settings for now
			}

			function showTapbackDialog(guid) {
				if (debug) console.log(`showing tapback dialog for guid ${guid}`);
				var existing = document.getElementById(`${guid}-tapback`);
				if (existing !== undefined && existing !== null) {
					existing.outerHTML = "";
					return;
				}

				var text = document.getElementById(guid);
				var dialog = document.createElement("span");
				var is_area = text.parentNode.className.includes("text-area");
				dialog.className = "text tapback_dialog";
				dialog.classList.add(text.className.includes("is_from_them") ? "is_from_them" : "is_from_me");
				dialog.classList.add(text.className.includes("iMessage") ? "iMessage" : "SMS");
				dialog.id = `${guid}-tapback`

				var sel = -1;
				if (is_area) {
					var my_taps = text.parentNode.getElementsByClassName("tapFromMe");
					if (my_taps.length > 0) var sel = Number(my_taps[0].getAttribute("tapbackType"));
				}

				for (var i = 0; i < fa_icons.length; i++) {
					var choice = document.createElement("span");
					choice.className = `tapback_choice${i === sel ? " tapback_chosen" : ""}`;
					choice.innerHTML = fa_icons[i];
					choice.setAttribute("onclick", `sendTapback("${guid}", ${i}, "${current_chat_id}", ${i === sel});`);

					dialog.appendChild(choice);
				}

				var trash = document.createElement("span");
				trash.className = "tapback_choice trash_text";
				trash.innerHTML = '<i class="fas fa-trash-alt"></i>';
				trash.setAttribute("onclick", `deleteText("${guid}", "${current_chat_id}");`);
				dialog.appendChild(trash);

				document.getElementById("text-content").insertBefore(dialog, is_area ? text.parentNode : text);
			}

			async function sendTapback(guid, tapback, chat = current_chat_id, remove = false) {
				if (debug) console.log(`sending tapback ${tapback} for guid ${guid} in chat ${chat}, remove: ${remove}`);
				var res = await getTextFromURL(`${prefix}/requests?tapback=${tapback}&tap_guid=${guid}&tap_in_chat=${chat}&remove_tap=${remove}`);
				if (res !== "true")
					alert("didn't send tapback :(");

				document.getElementById(`${guid}-tapback`).outerHTML = "";
			}

			async function deleteText(guid, chat = current_chat_id) {
				if (debug) console.log(`attempting to delete text ${guid} in chat ${chat}`);
				if (!confirm("Are you sure you want to delete the selected text?"))
					return;

				var res = await getTextFromURL(`${prefix}/requests?delete_chat=${chat}&delete_text=${guid}`);
				document.getElementById(`${guid}-tapback`).outerHTML = "";

				if (res !== "true") {
					alert("Couldn't delete chat :(");
				} else {
					var txt = document.getElementById(guid);
					if (txt.parentNode.className.includes("text-content"))
						txt.outerHTML = "";
					else
						txt.parentNode.outerHTML = "";
				}
			}

			function setUpDND() {
				if (debug) console.log("setting up dnd");
				var input_form = document.getElementById("sendform");
				input_form.ondragover = input_form.ondragenter = function(evt) {
					evt.preventDefault();
				}

				input_form.ondrop = function(evt) {
					var file_box = document.getElementById("attachmentbutton");
					file_box.files = evt.dataTransfer.files;
					if (file_box.files.length > 0) document.getElementById('unhiddenbutton').innerHTML = file_box.files.length;
					else document.getElementById("unhiddenbutton").innerHTML = '<i class="fas fa-paperclip"></i>';
					evt.preventDefault();
				}
			}

			window.addEventListener("focus", function(event) {
				if (current_chat_id.length === 0) return;
				var bt = document.querySelector(`[addresses*="${current_chat_id}"]`);
				if (bt === undefined || bt === null || !bt.className.includes("unread")) return;
				bt.className = bt.className.replace(/unread/g, "");
				var _ = fetchFromURL(`${prefix}/requests?person=${current_chat_id}&num=1`);

				var unreads = document.getElementsByClassName("unread").length;
				document.title = `SMServer${unreads > 0 ? " (" + String(unreads) + ")" : ""}`;
			});


			document.addEventListener("DOMContentLoaded", () => {
				if (!window.Notification || Notification.permission === "granted")
					document.getElementById("notificationbutton").outerHTML = "";

				if (subject) enableSubject();
				setUpDND();
			});

			printChats();

			let socket_prefix = location.protocol === "https:" ? "wss://" : "ws://";
			let socket = new WebSocket(`${socket_prefix}${socket_address}:${socket_port}`);

			socket.onmessage = function(event) {
				parseMessage(event.data);
			}

			socket.onerror = function(event) {
				if (!shown_ws_alert) alert(`It appears you may not have trusted the websocket certificate yet. Please navigate to https://${socket_address}:${socket_port} and trust the certificate there (If you have already trusted the websocket, you can ignore this message).`);
				shown_ws_alert = true;
			}

		</script>
		<link rel="stylesheet" type="text/css" href="style?fa_solid">
		<link rel="stylesheet" type="text/css" href="style?font_awesome">
		<link rel="stylesheet" type="text/css" href="style?main">
		<link rel="stylesheet" type="text/css" href="style?custom">
		<!--theme optional section; next line must remain as comment-->
		<!--light-->
		<!--nord-->
	</head>
	<body>
		<div class="everything">
			<div class="chats">
				<div class="chats-title" onclick="clearTextContent();">
					<h1>SMServer</h1>
					<div id="stats">
						<div id="battery">
							battery: 0%
							<span id="batterySymbol"></span>
						</div>
					</div>
				</div>
				<div class="chats-search">
					<input type="text" id="searchBox" placeholder="Search" onkeydown="if (event.keyCode === 13) submitSearch();"></input>
					<button onclick="Notification.requestPermission();" id="notificationbutton">Notifications</button>
					<button onclick="showPopup();" id="composeshowbutton"><i class="fas fa-plus-circle"></i> New</button>
				</div>
				<div class="chats-list">
					<button onclick="getMoreChats()" id="morechatsbutton"><i class="fas fa-chevron-circle-down"></i> More</button>
				</div>
			</div>
			<div class="messages">
				<div class="title">
					<span class="title-content" id="messagesTitleText"></span>
				</div>
				<div class="text-content" id="text-content">
					<div class="centered">Select a chat on the left to view your messages :)</div>
				</div>
				<iframe name="dummyframe" id="dummyframe" style="display: none;"></iframe>
				<form action="send" method="POST" enctype="multipart/form-data" id="sendform" class="textbox" target="dummyframe" name="sendform">
					<button type="button" onclick="displayCameraRoll();" id="camerarollbutton"><i class="fas fa-camera"></i></button>
					<button type="button" onclick="document.getElementById('attachmentbutton').click();" id="unhiddenbutton"><i class="fas fa-paperclip"></i></button>
					<input type="file" name="attachments" id="attachmentbutton" multiple onchange="document.getElementById('unhiddenbutton').innerHTML = document.getElementById('attachmentbutton').files.length;"></input>
					<input type="text" name="photos" id="hiddenphotobutton" style="display: none;">
					<textarea id="sendbox" class="input" name="text" oninput="if (event.keyCode !== 13) inputKeyDown();" form="sendform" onkeydown="if (event.keyCode === 13 && ! event.shiftKey){event.preventDefault(); sendForm();}"></textarea>
					<input type="text" name="chat" id="hiddenchatbox" form="sendform" style="display: none">
					<button type="button" id="sendbutton" onclick="sendForm();">↑</button>
				</form>
			</div>
			<div class="popup" id="popup">
				<div class="compose" id="compose">
					<form action="send" method="POST" enctype="multipart/form-data" id="composeform" class="composeTextBox" target="dummyframe" name="composeform">
						<div class="composeTitleBoxDiv">
							<button onclick="hidePopup();" id="composeHideButton">Cancel</button>
							<span id="composeTitleBoxTitle">New Message</span>
							<button onclick="sendComposeForm();" id="composeSendButton">Send</button>
						</div>
						<div class="composeAddressBoxDiv">
							<span class="composeAddressToDiv">To:</span>
							<input name="chat" id="composeAddressBox" form="composeform" placeholder="address here (e.g. '+19280372949')">
							<input value="&#128206" onclick="document.getElementById('composeAttachmentButton').click();" type="button" id="composeShowingAttachmentButton"></input>
							<input type="file" name="attachments" id="composeAttachmentButton" multiple onchange="document.getElementById('composeShowingAttachmentButton').value = document.getElementById('composeAttachmentButton').files.length.toString();"></input>
						</div>
						<textarea id="composeSendBox" form="composeform" placeholder="body here"></textarea>
						<textarea name="text" style="display: none;" form="composeform" id="hiddenComposeTextArea"></textarea>
					</form>
				</div>
			</div>
		<div class="camerarollpopup" id="camerarollpopup">
		<div class="cameraroll" id="cameraroll">
			<div id="camerarollTitle">
			<button onclick="hideCameraRoll();" id="camerarollHideButton">Cancel</button>
			<span id="camerarollTitleBoxTitle">Choose Camera Roll Images</span>
			<button onclick="selectCameraRollPhotos();" id="camerarollSelectButton">Select</button>
			</div>
			<div id="camerarollContent">
			<button class="photo" id="morephotosbutton" onclick="loadMoreCameraRoll();">+ More</button>
			</div>
		</div>
		</div>
		</div>
	</body>
</html>
