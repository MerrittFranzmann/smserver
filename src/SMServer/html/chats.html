<html>
	<head>
		<meta charset="utf-8" />
		<link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?" />
		<title>
			SMServer
		</title>
		<script>
			var new_chats = "";
			/// These next five lines need to remain without value, since they will be changed when swift parses the file.
			var num_texts_to_load;
			var num_chats_to_load;
			var num_photos_to_load;
			var socket_port;
			var debug;
			var subject;

			var printed_texts = 0;
			var printed_chats = 0;
			var printed_photos = 0;

			var has_shown_warning = false;
			var has_shown_camera_roll = false;
			var notifications = false;
			var has_shown_new_warning = false;
			var window_is_focused = true;
			var faLoaded = false;
			var currently_typing = false;
			var called_typing_wait = false;

			var items = "";
			var new_items = "";
			var shown_name = "";
			var texts = "";
			var image_string = "";
			var current_chat_id = "";
			var sleep_time = 400;
			var typing_sleep = 10000;

			var doc_url = window.location.href.split("/")[2].split(":")[0];
			var socket_address = doc_url;
			var prefix = "";

			if (doc_url === "127.0.0.1" || doc_url === "localhost") { /// when I'm debugging on local computer
				prefix = "http://192.168.0.180:8741";
				num_texts_to_load = 100;
				num_chats_to_load = 60;
				socket_port = 8740;
				socket_address = prefix.split("/")[2].split(":")[0];
			}

			function timeConverter(t) {
				var ts = (t / 1000000000) + 978307200;

				var a = new Date(ts * 1000);
				var months = ['Jan','Feb','Mar','Apr','May','Jun','Jul','Aug','Sep','Oct','Nov','Dec'];
				var year = a.getFullYear();
				var month = months[a.getMonth()];
				var date = a.getDate();
				var hour = a.getHours();
				var min = a.getMinutes();
				var time = date + ' ' + month + ' ' + year + ' ' + (hour < 10 ? '0' : '') + hour + ':' + (min < 10 ? '0' : '') + min;
				return time;
			}

			async function getTextFromURL(url) {
				var return_text = "";
				await fetch(url, {
					mode: 'no-cors',
				}).then(response => response.text())
				.then((response) => {
					return_text = response;
				})

				return return_text;
			}

			function setFALoaded() {
				faLoaded = true;
				var crb = document.getElementById("camerarollbutton");
				if (crb !== undefined) crb.innerHTML = "<i class=\"fas fa-camera\"></i>";
				var uhb = document.getElementById("unhiddenbutton");
				if (uhb !== undefined) uhb.innerHTML = "<i class=\"fas fa-paperclip\"></i>";
				if (uhb === undefined || crb === undefined) {
					document.addEventListener("DOMContentLoaded", () => {
						document.getElementById("camerarollbutton").innerHTML = "<i class=\"fas fa-camera\"></i>";
						document.getElementById("unhiddenbutton").innerHTML = "<i class=\"fas fa-paperclip\"></i>";
					});
				}
			}

			function getTextElement(text, last = false) {
				if (debug) { console.log("Getting text element for text " + text + (last ? ", last" : ", not last")); }

				if (Number(text.associated_message_type) < 2000 || text.associated_message_type === undefined) {

					var t = document.createElement("p");

					var classes = "text";
					if (last) classes += " more_texts";

					classes += (text.is_from_me === "0" ? " is_from_them" : " is_from_me") + " " + text.service;

					t.setAttribute("class", classes);
					t.setAttribute("id", text.guid);
					t.setAttribute("title", timeConverter(text.date));
					t.setAttribute("date_read", text.date_read);
					t.innerHTML = "";

					/// it's a rich link
					if (text.balloon_bundle_id === "com.apple.messages.URLBalloonProvider" && text.attachment_file !== undefined) {
						t.setAttribute("class", t.getAttribute("class") + " noPadding richLink");

						var img = document.createElement("img");
						var attachment_splits = text.attachment_file.split(":");
						img.src = "/data?path=" + (attachment_splits[1].length > 0 ? attachment_splits[1] : attachment_splits[0]);

						var under = document.createElement("a");
						under.href = text.text;
						under.setAttribute("class", "richLinkUnder");

						if (attachment_splits[1].length > 0) {
							t.appendChild(img);
							t.appendChild(document.createElement("br"));
						} else {
							under.appendChild(img);
							under.setAttribute("class", under.getAttribute("class") + " richLinkSmall");
						}

						var desc = document.createElement("div");
						desc.setAttribute("class", "richLinkDescription");

						var title = document.createElement("a");
						title.innerText = text.link_title;
						title.setAttribute("class", "richLinkTitle");
						desc.appendChild(title);

						if (attachment_splits[1].length > 0) {
							var subtitle = document.createElement("div");
							subtitle.innerText = text.link_subtitle;
							subtitle.setAttribute("class", "richLinkSubtitle");
							desc.appendChild(subtitle);
						}

						under.appendChild(desc);

						if (text.link_type !== undefined && text.link_type.split(".")[0] === "music") {
							var icon = document.createElement("div");
							icon.setAttribute("class", "richLinkIcon");

							var ii = document.createElement("img");
							ii.src = "/data?path=" + attachment_splits[0];
							icon.appendChild(ii);
							under.appendChild(icon);
						}

						t.appendChild(under);
						return t;
					}

					if (text.hasOwnProperty("attachment_file") && text.attachment_file.length != 0) {

						var files = text.attachment_file.split(":");
						var types = text.attachment_type.split(":");

						for (var l = 0; l < files.length; ++l) {
							if (types[l].length != 0 && types[l].substring(0, 5) === "image")
								t.innerHTML += "<img src=\"" + prefix + "/data?path=" + files[l] + "\"><br>";
							else if (files[l].length != 0)
								t.innerHTML += "<a href=\"" + prefix + "/data?path=" + files[l].replace(/ /g, "%20") + "\">Attachment: " + types[l] + "</a><br>";
						}
					}

					if (text.text.replace(/￼/g, "").trim().length > 0) {
						/// There's an invisible character between those first two quotes that displays on firefox.This just removes it so it doesn't look weird.
						var subject = document.createElement("div");
						subject.setAttribute("class", "subject");
						subject.innerText = text.subject;

						var inner = document.createElement("span");
						inner.innerText += text.text.replace(/￼/g, "");

						t.appendChild(subject);
						t.appendChild(inner);
					}

					return t;
				} else if (Number(text.associated_message_type) < 2006) {
					var guid = text.associated_message_guid.split("/")[1];

					var original = document.getElementById(guid);

					if (original === null || original === undefined) return document.createElement("span");

					var next = original.nextElementSibling;
					var copy = original.cloneNode(true);
					original.outerHTML = "";

					var area = document.createElement("span");
					var new_class = "text-area";
					new_class += copy.getAttribute("class").includes("is_from_them") ? " from_them" : " from_me";
					area.setAttribute("class", new_class);

					var reac = document.createElement("span");
					reac.setAttribute("class", "reaction");

					var icons = ["Love", "Thumbs up", "Thumbs down", "Haha", "!!", "??"];

					if (faLoaded) icons = ["<i class=\"fas fa-heart\"></i>", "<i class=\"fas fa-thumbs-up\"></i>", "<i class=\"fas fa-thumbs-down\"></i>",
					"<i class=\"fas fa-grin-tears\"></i>", "<i class=\"fas fa-exclamation\"></i><i class=\"fas fa-exclamation\"></i>", "<i class=\"fas fa-question\"></i>"];

					reac.innerHTML = icons[Number(text.associated_message_type) - 2000];

					area.appendChild(reac);
					area.appendChild(copy);

					document.getElementById("text-content").insertBefore(area, next);
				}

				return document.createElement("span");
			}

			function getChatElement(chat, num_texts) {
				if (debug) { console.log("Getting chat element for " + chat.chat_identifier + ", num: " + num_texts); }
				var b = document.createElement("button");

				b.setAttribute("id", chat.chat_identifier);

				var i = document.createElement("img");
				i.src = prefix + "/data?chat_id=" + chat.chat_identifier;

				var classes = chat.has_unread === "true" ? "unread" : "";

				var n = document.createElement("div");
				n.setAttribute("class", "chat-name");
				n.innerText = (chat.display_name.length === 0 ? chat.chat_identifier : chat.display_name);

				if (chat.pinned === "false") {
					b.appendChild(i);

					var nonpic = document.createElement("div");
					nonpic.setAttribute("class", "chat-nonpic");

					var top = document.createElement("div");
					top.setAttribute("class", "chat-toprow");

					if (chat.chat_identifier.substring(0, 4) !== "chat" && chat.display_name.length !== 0)
						n.innerHTML += "<span style=\"color: #858585; font-weight: 200;\"> (" + chat.chat_identifier + ")</span>";

					top.appendChild(n);

					var d = document.createElement("div");
					d.setAttribute("class", "chat-date");
					d.innerText = chat.relative_time;
					top.appendChild(d);
					nonpic.appendChild(top);

					var t = document.createElement("div");
					t.setAttribute("class", "chat-text");
					t.innerText = chat.latest_text.replace(/￼/g, "");
					nonpic.appendChild(t);
					b.appendChild(nonpic);

					classes += " unpinned";
				} else {
					var t = document.createElement("div");
					t.setAttribute("class", "chat-top");
					t.appendChild(i);

					if (chat.has_unread === "true") {
						var ct = document.createElement("div");
						ct.setAttribute("class", "chat-text");
						ct.innerText = chat.latest_text.replace(/￼/g, "");

						t.appendChild(ct);
					}

					b.appendChild(t);
					b.appendChild(n);
					classes += " pinned";
				}

				b.setAttribute("class", classes);

				var get_texts_string = "getTexts(\"" + chat.chat_identifier + "\", " + num_texts + ");";
				b.setAttribute("onclick", get_texts_string);

				return b;
			}

			async function getLatestText(chat = current_chat_id, read = false) {
				if (debug) { console.log("Getting latest text for chat " + chat); }
				var text;

				let url = prefix + "/requests?person=" + chat + "&num=1&read=" + (read ? "true" : "false");

				const fetch_one_text = await fetch(url)
				.then(response => {
					if (!response.ok)
						throw new Error("HTTP error " + response.status);
					return response.json();
				})
				.then(json => {
					text = (json.texts)[0];
					return text;
				})
				.catch(error => {
					if (!has_shown_warning) alert("The server restarted, you need to reload and re-authenticate. (fetch_one_text func)");
					has_shown_warning = true;
				})

				var text = await fetch_one_text;
				var content = document.getElementById("text-content");

				var more = document.getElementsByClassName("more_texts");
				if (more.length > 0) more[0].setAttribute("class", more[0].getAttribute("class").replace(" more_texts", ""));

				var is_group = chat.substring(0, 4) === "chat";

				var t = getTextElement(text, true);
				var senders = document.getElementsByClassName("sender");

				if (is_group && senders.length > 0 && text.is_from_me === "0" && text.sender !== senders[senders.length - 1].firstChild.innerText) {
					var name = document.createElement("div");

					name.innerHTML = "<p>" + text.sender + "</p>";
					name.setAttribute("class", "sender");

					content.appendChild(name);
				}					

				content.appendChild(t);
				t.scrollIntoView();
			}

			const getChats = async (offset = 0) => {
				if (debug) { console.log("getting chats with offset " + offset); }
				let url = prefix + "/requests?chat=0&num_chats=" + num_chats_to_load + "&chats_offset=" + offset;
				const fetch_val = await fetch(url)
				.then(response => {
					if (!response.ok)
						throw new Error("HTTP error " + response.status);
					return response.json();
				})
				.then(json => {
					this.items = (json.chats)
					return items
				})
				.catch(function () {
					if (!has_shown_warning) alert("The server restarted, you need to reload and re-authenticate. (getChats func)");
					has_shown_warning = true;
				})
			}

			const printChats = async () => {
				if (debug) { console.log("printing Chats"); }
				var new_items = await getChats();
				const num_texts = num_texts_to_load;
				var doc = document.getElementsByClassName("chats-list")[0];
				var old_button = document.getElementById("morechatsbutton");

				var selected_id = "";
				var selecteds = document.getElementsByClassName("selected");
				if (selecteds.length > 0)
					selected_id = selecteds[0].id;

				doc.innerHTML = "";
				doc.appendChild(old_button);

				printed_chats = num_chats_to_load;

				for(var i = 0; i < items.length; i++) {

					var b = getChatElement(items[i], num_texts);

					if (items[i].chat_identifier == selected_id)
						b.setAttribute("class", b.getAttribute("class") + " selected");

					if (b.getAttribute("class").includes("unpinned")) {
						doc.insertBefore(b, document.getElementById("morechatsbutton"));
					} else {
						var pinRows = document.getElementsByClassName("pinRow");

						if (pinRows.length > 0 && pinRows[pinRows.length - 1].firstChild.children.length < 3) {
							pinRows[pinRows.length - 1].firstChild.appendChild(b);
						} else {
							var row = document.createElement("div");
							row.setAttribute("class", "pinRow");

							var inner = document.createElement("div");
							inner.setAttribute("class", "innerRow");

							inner.appendChild(b);
							row.appendChild(inner);

							if (doc.children.length === 0)
								doc.appendChild(row);
							else if (pinRows.length === 0)
								doc.insertBefore(row, doc.firstChild);
							else if (pinRows.length > 0)
								doc.insertBefore(row, pinRows[pinRows.length - 1].nextSibling);
						}
					}
				}

				var unread_chats = document.getElementsByClassName("unread").length;
				document.title = "SMServer" + (unread_chats > 0 ? " (" + String(unread_chats) + ")" : "");
			}

			const moreJsonChats = async (offset = 0) => {
				if (debug) { console.log("Calling moreJsonChats with offset " + offset); }
				let url = prefix + "/requests?chat=0&num_chats=" + num_chats_to_load + "&chats_offset=" + offset
				const fetch_val = await fetch(url)
				.then(response => {
					if (!response.ok)
						throw new Error("HTTP error " + response.status);
					return response.json();
				})
				.then(json => {
					this.new_items = (json.chats)
					return new_items
				})
				.catch(function () {
					if (!has_shown_warning) alert("The server restarted, you need to reload and re-authenticate. (moreJsonChats func)");
					has_shown_warning = true;
				})
			}

			const getMoreChats = async () => {
				if (debug) { console.log("getting more chats"); }
				var _ = await moreJsonChats(printed_chats);
				printed_chats += num_chats_to_load;
				var doc = document.getElementsByClassName("chats-list")[0];

				for(var i = 0; i < new_items.length; i++) {

					var b = getChatElement(new_items[i], num_texts_to_load);
					doc.insertBefore(b, document.getElementById("morechatsbutton"));
				}
			}

			const getTexts = async (chat_id, num_texts) => {
				if (debug) { console.log("getting " + num_texts + " for chat " + chat_id); }

				var myNode = document.getElementsByClassName("text-content")[0];

				var selected = document.getElementsByClassName("selected");
				if (selected.length > 0)
					selected[0].setAttribute("class", selected[0].getAttribute("class").replace("selected", ""));

				var hiddenchatbox = document.getElementById("hiddenchatbox");
				hiddenchatbox.setAttribute("value", chat_id);

				var orig_btn = document.getElementById(chat_id);
				orig_btn.setAttribute("class", orig_btn.getAttribute("class").replace(/unread/g, "") + " selected");
				var unread_chats = document.getElementsByClassName("unread").length;
				document.title = "SMServer" + (unread_chats > 0 ? " (" + String(unread_chats) + ")" : "");

				if (!orig_btn.getAttribute("class").includes("unpinned") && orig_btn.getElementsByClassName("chat-text").length > 0)
					orig_btn.getElementsByClassName("chat-text")[0].outerHTML = "";

				var new_chat_id = chat_id;
				let url = prefix + "/requests?person=" + new_chat_id + "&num=" + num_texts;
				const fetch_texts = await fetch(url)
				.then(response => {
					if (!response.ok)
						throw new Error("HTTP error " + response.status);
					return response.json();
				})
				.then(json => {
					this.texts = (json.texts)
					return texts
				})
				.catch(function () {
					has_shown_warning ? 0 : alert("The server restarted, you need to reload and re-authenticate. (fetch_texts func)")
					has_shown_warning = true;
				})

				var chat_title = document.getElementById(chat_id).getElementsByClassName("chat-name")[0];
				var title_doc = document.getElementsByClassName("title-content")[0];
				title_doc.innerHTML = "<p>" + chat_title.innerHTML + "</p>";

				current_chat_id = chat_id;

				var img = document.createElement("img");
				img.src = prefix + "/data?chat_id=" + chat_id;

				title_doc.insertBefore(img, title_doc.firstChild);

				var _ = await fetch_texts;

				myNode.innerHTML = "";

				var more = document.createElement("button");
				more.setAttribute("onclick", "getMoreTexts()");
				more.setAttribute("id", "moretextsbutton");
				more.innerHTML = "<p>+ More Texts</p>";
				myNode.appendChild(more);

				printed_texts = texts.length;
				texts = texts.reverse();

				var is_group = chat_id.substring(0, 4) === "chat";
				var doc = document.getElementsByClassName("text-content")[0];

				for (var i = 0; i < texts.length; i++) {

					var t = getTextElement(texts[i], i === texts.length - 1);

					if (t.innerHTML.length > 0) {
						if (i === 0 || texts[i].date - texts[i - 1].date > 3600000000000) {
							var time = document.createElement("div");
							time.setAttribute("class", "time-display");

							var formattedTime = timeConverter(texts[i].date);

							time.innerHTML = "<p>" + formattedTime + "</p>";
							doc.appendChild(time);
						}

						if (is_group && texts[i].is_from_me === "0" && (i === 0 || texts[i].sender !== texts[i - 1].sender)) {
							var from = document.createElement("div");

							from.innerHTML = "<p>" + texts[i].sender + "</p>";
							from.setAttribute("class", "sender");

							doc.appendChild(from);
						}
					}

					doc.appendChild(t);
				}

				document.getElementById("sendbox").focus();

				var my_texts = document.getElementsByClassName("is_from_me");

				if (my_texts.length > 0) {
					var my_last_text;

					for (var i = my_texts.length - 1; i > 0 && my_texts[0].getAttribute("date_read") !== "0"; i--) {
						if (my_texts[i].getAttribute("date_read") !== "0") {
							my_last_text = my_texts[i];
							break;
						}
					}

					if (my_last_text !== undefined) {

						var isimsg = (my_last_text.getAttribute("class").includes("text-area") ? my_last_text.lastChild : my_last_text).getAttribute("class").includes("iMessage");

						if (!is_group && my_last_text.getAttribute("date_read") !== "0" && isimsg) {
							var rr = document.createElement("span");
							rr.setAttribute("class", "readreceipt");
							rr.innerText = "Read " + timeConverter(parseInt(my_last_text.getAttribute("date_read")));

							if (my_last_text === doc.lastChild)
								doc.appendChild(rr);
							else
								doc.insertBefore(rr, my_last_text.nextSibling);
						}
					}
				}
											  
				document.getElementById("text-content").lastChild.scrollIntoView();
			}

			const getMoreTexts = async (num_texts = num_texts_to_load) => {
				if (debug) { console.log("called getMoreText; num == " + num_texts); }
				var chat_id = current_chat_id;

				var new_chat_id = chat_id;
				let url = prefix + "/requests?person=" + new_chat_id + "&num=" + num_texts_to_load + "&offset=" + printed_texts + "&read=false";
				const fetch_texts = await fetch(url)
				.then(response => {
					if (!response.ok)
						throw new Error("HTTP error " + response.status);
					return response.json();
				})
				.then(json => {
					this.texts = (json.texts)
					return texts
				})
				.catch(function () {
					if (!has_shown_warning) alert("The server restarted, you need to reload and re-authenticate. (fetch_more_texts func)");
					has_shown_warning = true;
				})

				var _ = await fetch_texts;

				printed_texts += texts.length;

				var last_item = document.createElement("br");
				var first_item = document.getElementsByClassName("text-content")[0];

				var is_group = chat_id.substring(0, 4) === "chat";
				var doc = document.getElementsByClassName("text-content")[0];

				for (var i = 0; i < texts.length; i++) {

					var t = getTextElement(texts[i], i === 0);

					if (i != 0 && texts[i].date - texts[i - 1].date < -3600000000000) {
						var time = document.createElement("div");
						time.setAttribute("class", "time-display");

						var formattedTime = timeConverter(texts[i - 1].date);

						time.innerHTML = "<p>" + formattedTime + "</p>";
						doc.insertBefore(time, document.getElementById("moretextsbutton").nextSibling);
					}
											  
					doc.insertBefore(t, document.getElementById("moretextsbutton").nextSibling);

					if (is_group && texts[i].is_from_me === "0" && ((i !== texts.length - 1 && texts[i].sender !== texts[i + 1].sender) || (i === texts.length - 1))){
						var from = document.createElement("div");

						from.innerHTML = "<p>" + texts[i].sender + "</p>";
						from.setAttribute("class", "sender");

						doc.insertBefore(from, document.getElementById("moretextsbutton").nextSibling);
					}
				}
			}

			const getImage = async (chat_id) => {
				if (debug) { console.log("calling getImage for chat " + chat_id); }

				var url = prefix + "/requests?image=" + chat_id;
				const fetch_image = await fetch(url)
				.then(response => {
					if (!response.ok)
						throw new Error("HTTP error " + response.status);
					return response.text();
				})
				.then(text => {
					this.image_string = text
					return image_string
				})
				.catch(function () {
					if (!has_shown_warning) alert("The server restarted, you need to reload and re-authenticate. (fetch_image func)");
					has_shown_warning = true;
				})
			}

			function sleep(ms) {
				return new Promise(resolve => setTimeout(resolve, ms));
			}

			async function sendForm() {
				if (debug) { console.log("sending form"); }
				var form = document.getElementById("sendform");

				typing_sleep = 0;

				var tbox = document.getElementById("sendbox");
				var oldval = tbox.value;

				var photos = document.getElementById("hiddenphotobutton");
				var selected = document.getElementsByClassName("selected-photo");
				for (var i = 0; i < selected.length; ++i) {
					photos.value += selected[i].id + (i !== selected.length - 1 ? ":" : "");
				}

				var submit = (oldval.length > 0 || selected.length > 0 || document.getElementById("attachmentbutton").files.length > 0);
				var has_attachments = (selected.length > 0 || document.getElementById("attachmentbutton").files.length > 0);

				if (submit) {
					form.submit();

					tbox.value = "";
					var subval = "";
					if (subject) {
						subval = document.getElementById("subjectBox").value;
						document.getElementById("subjectBox").value = "";
					}

					document.getElementById("attachmentbutton").value = "";
					document.getElementById("unhiddenbutton").innerHTML = faLoaded ? "<i class=\"fas fa-paperclip\"></i>" : "📎";
					hideCameraRoll(); /// Since it changes the photo button value and unselects all the currently selected photos
					photos.value = "";

					autoGrow();

					if (has_attachments) {
						await sleep(sleep_time);

						getLatestText();
					} else {
						var omt = document.getElementsByClassName("more_texts")[0];
						omt.setAttribute("class", omt.getAttribute("class").replace("more_texts", ""));

						var nt = document.createElement("p");
						var im = document.getElementById("text-content").lastChild.getAttribute("class").includes("iMessage");
						nt.setAttribute("class", "text more_texts is_from_me" + (im ? " iMessage" : " SMS"));

						var topsub = document.createElement("div");
						topsub.setAttribute("class", "subject");
						topsub.innerText = subval;

						var bottomtext = document.createElement("span");
						bottomtext.innerText = oldval;

						nt.innerHTML = topsub.outerHTML + bottomtext.outerHTML;

						document.getElementById("text-content").appendChild(nt);
						nt.scrollIntoView();

						await sleep(sleep_time);
					}

					setChatAsTop(current_chat_id, oldval);
				}
			}

			async function sendComposeForm() {
				if (debug) { console.log("sending Compose form"); }
				hidePopup();

				var form = document.getElementById("composeform");
				var tbox = document.getElementById("composeSendBox");
				var oldval = tbox.value;

				var hta = document.getElementById("hiddenComposeTextArea");
				hta.value = oldval;

				var cbox = document.getElementById("composeAddressBox");
				var coldval = cbox.value;
				cbox.value = coldval;

				form.submit();

				setChatAsTop(coldval, oldval);

				await sleep(500);

				tbox.value = "";
				hta.value = "";
				cbox.value = "";
				document.getElementById("composeShowingAttachmentButton").value = "";
				document.getElementById("composeAttachmentButton").value = "";
			}
						  
			function inputKeyDown() {
				autoGrow();
				if (current_chat_id !== "") {
					if (document.getElementById("sendbox").value.length > 0) {
						typing_sleep = 10000;
						if (!currently_typing) socket.send("typing:" + current_chat_id);
						currently_typing = true;
						typingWait();
					} else {
						typing_sleep = 0;
					}
				}
			}
						  
			async function typingWait() {
				if (!called_typing_wait) {
					called_typing_wait = true;
					while (typing_sleep > 0) {
						typing_sleep -= 200;
						await sleep(200);
					}
					if (currently_typing) {
						currently_typing = false;
						socket.send("idle:" + current_chat_id);
					}
					called_typing_wait = false;
				}
			}

			async function autoGrow() {
				var elem = document.getElementById("sendbox");
				elem.style.height = getComputedStyle(document.documentElement).getPropertyValue("--send-button-size");
				var scroll_height = elem.scrollHeight;
				elem.style.height = scroll_height + "px";

				/// I don't know why this next section is necessary but it is
				if (elem.value === "") {
					var uhb = document.getElementById("unhiddenbutton");
					var crb = document.getElementById("camerarollbutton");

					await uhb.setAttribute("style", "margin: 0 !important;");
					await crb.setAttribute("style", "margin: 0 !important;");
					await sleep(1); /// Why do I need this. so dumb
					await uhb.setAttribute("style", "margin: auto 0;");
					await crb.setAttribute("style", "margin: auto 0;");
				}

				document.getElementById("text-content").lastChild.scrollIntoView();
			}

			function showPopup() {
				document.getElementById("popup").style.display = "block";

				if (!has_shown_new_warning) {
					alert("IMPORTANT: When using the compose box, you must type in the full phone number of the recipient, including a plus sign (+) before the country code. See hint for example.");
					self.has_shown_new_warning = true;
				}
			}

			function hidePopup() {
				var pop = document.getElementById("popup");
				pop.style.display = "none";
			}

			let socket_prefix = location.protocol === "https:" ? "wss://" : "ws://";
			let socket = new WebSocket(socket_prefix + socket_address + ":" + socket_port);

			socket.onmessage = function(event) {
				parseMessage(event.data);
			}

			socket.onerror = function(event) {
				alert("It appears you have not yet trusted the websocket certificate. Please navigate to https://" + socket_address + ":" + socket_port + "/ and trust the certificate there");
			}

			function parseMessage(msg) {
				if (debug) { console.log("parsing message " + msg); }
				var split = msg.split(":");

				var prefix = split[0];
				var content = "";
				if (split.length > 0) content = split[1];

				switch (prefix) {
					case "text":
						processNewText(content);
						break
					case "battery":
						setNewBatteryLevel(content);
						break
					case "typing":
						setChatAsTyping(content);
						break
					default:
						console.log("cannot handle request: '" + msg + "'");
						break
				}
			}

			async function processNewText(chat) {
				if (debug) { console.log("received new text from " + chat); }

				var new_text = "";
				var name = "";
				var notif_text;

				if (window.Notification && Notification.permission === "granted" && (!window_is_focused || chat !== current_chat_id)) {
					var url = prefix + "/requests?person=" + chat + "&num=1&read=false";
					const fetch_newest_text = await fetch(url)
					.then(response => {
						if (!response.ok)
							throw new Error("HTTP error " + response.status);
						return response.json();
					})
					.then(json => {
						notif_text = (json.texts)[0]
						return new_text
					})
					.catch(function () {
						if (!has_shown_warning) alert("The server restarted, you need to reload and re-authenticate. (fetch_more_texts func)");
						has_shown_warning = true
					}) 

					var _ = await fetch_newest_text;
					name = await getTextFromURL(prefix + "/requests?name=" + chat);

					new_text = notif_text.text;

					if (notif_text.sender !== undefined && notif_text.sender !== "nil")
						new_text = notif_text.sender + ": " + new_text;

					if (notif_text.text.replace(/￼/g, "").trim() === "" && notif_text.cache_has_attachments === "1")
						new_text = "Attachment: " + notif_text.attachment_type.split(":")[0];

					var n = new Notification(name, { body: new_text, icon: "/favicon.ico"});
				}

				if (chat.length !== 0) {
					if (document.getElementById(chat) === undefined || chat == "any") {
						printChats();
					} else if (chat !== document.getElementsByClassName("unpinned")[0].id && document.getElementById(chat).getAttribute("class").includes("unpinned")) {
						if (new_text !== "")
							setChatAsTop(chat, new_text);
						else
							setChatAsTop(chat);
					} else {
						var url = prefix + "/requests?person=" + chat + "&num=1&read=false";
						const fetch_newest_text = await fetch(url)
						.then(response => {
							if (!response.ok)
							throw new Error("HTTP error " + response.status);
							return response.json();
						})
						.then(json => {
							notif_text = (json.texts)[0];
							return new_text;
						})
						.catch(function () {
							if (!has_shown_warning) alert("The server restarted, you need to reload and re-authenticate. (fetch_more_texts func)");
							has_shown_warning = true;
						})

						var _ = await fetch_newest_text;

						var btn = document.getElementById(chat);

						new_text = notif_text.text;

						if (notif_text.sender !== undefined && notif_text.sender !== "nil")
							new_text = notif_text.sender + ": " + new_text;

						if (notif_text.text.replace(/￼/g, "").trim() === "" && notif_text.cache_has_attachments === "1")
							new_text = "Attachment: " + notif_text.attachment_type.split(":")[0];

						if (btn !== undefined) {
							if (chat !== current_chat_id) btn.setAttribute("class", btn.getAttribute("class") + " unread");
							if (btn.getAttribute("class").includes("unpinned") || btn.getElementsByClassName("chat-text")[0] !== undefined) {
								var text = btn.getElementsByClassName("chat-text")[0];

								if (text !== undefined) text.innerText = new_text;
							} else if (chat !== current_chat_id) {
								var text = document.createElement("div");
								text.setAttribute("class", "chat-text");
								text.innerText = new_text;

								var tb = btn.getElementsByClassName("chat-top")[0];
								tb.appendChild(text);
							}
						}
					}
					if (chat === current_chat_id) {
						getLatestText(current_chat_id, window_is_focused);
						var typ = document.getElementById("typingIndicator");
						if (typ !== undefined && typ !== null) typ.outerHTML = "";
					}
				}

				var unread_chats = document.getElementsByClassName("unread").length;
				document.title = "SMServer" + (unread_chats > 0 ? " (" + String(unread_chats) + ")" : "");
			}
						  
			async function setChatAsTop(chat, new_text = "") {
				if (debug) { console.log("Setting chat as top: " + chat + ", new: " + new_text); }

				var chatsList = document.getElementsByClassName("chats-list")[0];
				var unpins = document.getElementsByClassName("unpinned");
				var current_box = document.getElementById(chat);

				if ((current_box && !current_box.getAttribute("class").includes("unpinned")) || (unpins.length > 0 && chat === unpins[0].id)) {
					if (new_text !== "" && current_box.getAttribute("class").includes("unpinned"))
						current_box.getElementsByClassName("chat-text")[0].innerText = new_text;

					if (!window_is_focused || current_chat_id !== chat)
						current_box.setAttribute("class", current_box.getAttribute("class") + " unread")
				} else {
					var last_text;
					var url = prefix + "/requests?person=" + chat + "&num=1&read=false"; /// The most recent text from this person has (nearly) all the info we need
					const fetch_recent_chat = await fetch(url)
					.then(response => {
						if (!response.ok)
							throw new Error("HTTP error " + response.status);
						return response.json();
					})
					.then(json => {
						last_text = (json.texts)[0]
						return last_text;
					})
					.catch(function () {
						if (!has_shown_warning) alert("The server restarted, you need to reload and re-authenticate. (fetch_more_texts func)");
						has_shown_warning = true
					})

					var _ = await fetch_recent_chat;

					var new_chat = {
						'time_marker': last_text.date,
						'pinned': 'false',
						'latest_text': last_text.text,
						'chat_identifier': chat,
						'display_name': chat,
						'has_unread': 'false',
						'relative_time': 'now',
					}

					var existingButton = document.getElementById(chat);
					if (existingButton) {
						new_chat.pinned = existingButton.getAttribute("class").includes("unpinned") ? "false" : "true";
						new_chat.display_name = existingButton.getElementsByClassName("chat-name")[0].firstChild.textContent;
						existingButton.outerHTML = "";
					} else {
						new_chat.display_name = await getTextFromURL("/requests?name=" + chat);
					}

					var new_box = getChatElement(new_chat);

					if (new_text.length > 0) new_box.getElementsByClassName("chat-text")[0].innerText = new_text;

					var pinRows = document.getElementsByClassName("pinRow");

					if (pinRows.length === 0)
						chatsList.insertBefore(new_box, chatsList.firstChild);
					else
						chatsList.insertBefore(new_box, pinRows[pinRows.length - 1].nextSibling);
				}

			}

			function setSelectedPhoto(url) {
				if (debug) { console.log("setting selected photo for " + url); }
				var p = document.getElementById(url);
				if (p.getAttribute("class").includes("selected-photo"))
					p.setAttribute("class", "photo");
				else
					p.setAttribute("class", p.getAttribute("class") + " selected-photo");
			}

			function getPhotoElement(photo) {
				if (debug) { console.log("Getting photo element " + photo); }
				var p = document.createElement("span");

				var c = "photo";
				if (photo.is_favorite === "true")
					c += " is_favorite";

				p.setAttribute("class" , c);

				p.setAttribute("id", photo.URL);
				p.setAttribute("onclick", "setSelectedPhoto(\"" + photo.URL + "\");");
				p.setAttribute("width", "160");
				p.setAttribute("height", "160");

				p.innerHTML = "<img src=\"" + prefix + "/data?photo=" + photo.URL + "\">";

				if (photo.is_favorite === "true") {
					var h = document.createElement("span");
					h.setAttribute("class", "favorite-heart");
					h.innerHTML = faLoaded ? "<i class=\"fas fa-heart\"></i>" : "❤";
					if (faLoaded)
						h.setAttribute("style", "padding-right: 24px") /// It's annoyingly specific, 1px off from using unicode
					p.appendChild(h);
				}
				return p;
			}

			async function displayCameraRoll() {
				if (debug) { console.log("Displaying camera roll"); }
				document.getElementById("camerarollpopup").style.display = "block";

				var cr = document.getElementById("camerarollContent");

				if (!has_shown_camera_roll) {
					var photos;

					var url = prefix + "/requests?photos=" + num_photos_to_load;
					const fetch_recent_photos = await fetch(url)
					.then(response => {
						if (!response.ok)
							throw new Error("HTTP error " + response.status);
						return response.json();
					})
					.then(json => {
						photos = (json.photos);
						return photos;
					})
					.catch(function () {
						if (!has_shown_warning) alert("The server restarted, you need to reload and re-authenticate. (fetch_recent_photos func)");
						has_shown_warning = true;
					})

					var _ = await fetch_recent_photos;
					if (photos.length === 0) var _ = await fetch_recent_photos;

					printed_photos += photos.length;

					for (var i = 0; i < photos.length; i++) {
						var p = await getPhotoElement(photos[i]);

						cr.insertBefore(p, cr.children[cr.children.length - 1]); /// I should just do cr.lastChild but it doesn't work
					}
					has_shown_camera_roll = true;
				}
			}

			async function loadMoreCameraRoll() {
				var cr = document.getElementById("camerarollContent");
				var new_photos;

				var url = prefix + "/requests?photos=" + num_photos_to_load + "&photo_offset=" + printed_photos;
				const fetch_new_photos = await fetch(url)
				.then(response => {
					if (!response.ok)
						throw new Error("HTTP error " + response.status);
					return response.json();
				})
				.then(json => {
					new_photos = (json.photos);
					return new_photos;
				})
				.catch(function () {
					has_shown_warning ? 0 : alert("The server restarted, you need to reload and re-authenticate. (fetch_recent_photos func)")
					has_shown_warning = true;
				}) 

				var _ = await fetch_new_photos;
				printed_photos += new_photos.length;

				for (var i = 0; i < new_photos.length; i++) { 
					var p = await getPhotoElement(new_photos[i]);

					cr.insertBefore(p, cr.children[cr.children.length - 1]);
				}
			}

			function hideCameraRoll() {
				document.getElementById("camerarollpopup").style.display = "none";
				var p = document.getElementsByClassName("selected-photo");

				for (var i = p.length - 1; i >= 0; --i) {
					p[i].setAttribute("class", p[i].getAttribute("class").replace("selected-photo", ""));
				}

				document.getElementById("camerarollbutton").innerHTML = faLoaded ? "<i class=\"fas fa-camera\"></i>" : "📷";
			}

			function selectCameraRollPhotos() {
				document.getElementById("camerarollpopup").style.display = "none";

				document.getElementById("camerarollbutton").innerHTML = document.getElementsByClassName("selected-photo").length;
			}

			function setNewBatteryLevel(level) {
				if (debug) { console.log("new battery level: " + level); }
				var batt = document.getElementById("battery");
				var bat_symbol = document.getElementById("batterySymbol");

				var symbol = "";
				if (isNaN(level)) {

					if (level === "charging")
						symbol = " <i id=\"chargingSymbol\" class=\"fas fa-bolt\"></i>";
					
					var cgs = document.getElementById("chargingSymbol");
					if (cgs !== undefined && cgs !== null)
						cgs.outerHTML = symbol;
					else
						bat_symbol.innerHTML = symbol + bat_symbol.innerHTML;

				} else {
					var dbl = ~~Number(level);

					if (faLoaded) {
						if (dbl < 5)
							symbol = " <i id=\"levelSymbol\" class=\"fas fa-battery-empty\"></i>";
						else if (dbl < 25)
							symbol = " <i id=\"levelSymbol\" class=\"fas fa-battery-quarter\"></i>";
						else if (dbl < 50)
							symbol = " <i id=\"levelSymbol\" class=\"fas fa-battery-half\"></i>";
						else if (dbl < 75)
							symbol = " <i id=\"levelSymbol\" class=\"fas fa-battery-three-quarters\"></i>";
						else
							symbol = " <i id=\"levelSymbol\" class=\"fas fa-battery-full\"></i>";
					}

					var lvs = document.getElementById("levelSymbol");
					if (lvs !== undefined && lvs !== null)
						lvs.outerHTML = symbol;
					else
						bat_symbol.innerHTML = bat_symbol.innerHTML + symbol;

					batt.innerHTML = String(level).split(".")[0] + "%" + bat_symbol.outerHTML;

					if (dbl > 35)
						batt.setAttribute("class", "fullEnough");
					else if (dbl > 20)
						batt.setAttribute("class", "risky");
					else
						batt.setAttribute("class", "low");
				}
			}
						  
			function setChatAsTyping(chat) {
				if (chat === current_chat_id) {
					var d = document.createElement("div");
					d.setAttribute("class", "text is_from_them iMessage");
					d.setAttribute("id", "typingIndicator");

					d.innerHTML = "<span class=\"dot flashing\">• </span><span class=\"dot\">• </span><span class=\"dot\">•</span>";

					document.getElementById("text-content").appendChild(d);
					d.scrollIntoView();

					var c = 0;
					var typing = window.setInterval(() => {
						var i = document.getElementById("typingIndicator");
						if (i === null) clearInterval(typing);
						i.children[c].setAttribute("class", "dot");
						c = (c + 1) % 3;
						i.children[c].setAttribute("class", "dot flashing");
					}, 400);
				}
			}

			function enableSubject() {
				var tbox = document.getElementById("sendbox");
				var ntbox = tbox.cloneNode(false);
				ntbox.setAttribute("class", "subjectInput");
				ntbox.setAttribute("placeholder", "body");

				var con = document.createElement("div");
				con.setAttribute("class", "subjectTextarea");

				var sbox = document.createElement("textarea");
				sbox.setAttribute("class", "subjectSubject");
				sbox.setAttribute("id", "subjectBox");
				sbox.setAttribute("name", "subject");
				sbox.setAttribute("oninput", tbox.getAttribute("oninput"));
				sbox.setAttribute("onkeydown", tbox.getAttribute("onkeydown"));
				sbox.setAttribute("form", tbox.getAttribute("form"));
				sbox.setAttribute("placeholder", "Subject");

				con.innerHTML = sbox.outerHTML + ntbox.outerHTML;
				tbox.outerHTML = con.outerHTML;

				document.documentElement.style.setProperty("--messages-send-height", "64px"); /// hardcoded. not a fan. should fix
				document.documentElement.style.setProperty("--send-box-size", "calc((var(--messages-send-height) / 2) - 6px)");
				document.getElementById("sendbutton").setAttribute("class", "hasSubject");

				document.getElementById("camerarollbutton").style.margin = "auto 0";
				document.getElementById("unhiddenbutton").style.margin = "auto 0";
			}

			function submitSearch() {
				var term = document.getElementById("searchBox").value;
				window.location.href = prefix + "/requests?search=" + term; /// uhh simple stuff; use default settings for now
			}

			window.onfocus = function() { self.window_is_focused = true; }
			window.onblur = function() { self.window_is_focused = false; }

			document.addEventListener("DOMContentLoaded", () => {
				if (!window.Notification || Notification.permission === "granted")
					document.getElementById("notificationbutton").outerHTML = "";

				if (subject) enableSubject();
			});

			printChats();

		</script>
		<!-- These next links are for fontawesome; it's how I display the reactions. It's safe to remove them, but then the reactions will just appear as text instead of icons-->
		<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.14.0/css/solid.css" onload="setFALoaded();">
		<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.14.0/css/fontawesome.css">
		<link rel="stylesheet" type="text/css" href="style?main">
		<link rel="stylesheet" type="text/css" href="style?custom">
		<!--theme optional section; next line must remain as comment-->
		<!--light-->
		<!--nord-->
	</head>
	<body>
		<div class="everything">
			<div class="chats">
				<div class="chats-title">
					<h1>SMServer</h1>
					<div id="stats">
						<div id="battery">
							battery: 0%
							<span id="batterySymbol"></span>
						</div>
					</div>
				</div>
				<div class="chats-search">
					<input type="text" id="searchBox" placeholder="Search" onkeydown="if (event.keyCode === 13) submitSearch();"></input>
					<button onclick="Notification.requestPermission();" id="notificationbutton"><p>Notifications</p></button>
					<button onclick="showPopup();" id="composeShowButton"><p>+ New</p></button>
				</div>
				<div class="chats-list">
					<button onclick="getMoreChats()" id="morechatsbutton"><p>+ More Chats</p></button>
				</div>
			</div>
			<div class="messages">
				<div class="title">
					<span class="title-content"></span>
				</div>
				<div class="text-content" id="text-content">
					<div class="centered">Select a chat on the left to view your messages :)</div>
				</div>
				<iframe name="dummyframe" id="dummyframe" style="display: none;"></iframe>
				<form action="send" method="POST" enctype="multipart/form-data" id="sendform" class="textbox" target="dummyframe" name="sendform">
					<button type="button" onclick="displayCameraRoll();" id="camerarollbutton">&#128247</button>
					<button type="button" onclick="document.getElementById('attachmentbutton').click();" id="unhiddenbutton">&#128206</button>
					<input type="file" name="attachments" id="attachmentbutton" multiple onchange="document.getElementById('unhiddenbutton').innerHTML = document.getElementById('attachmentbutton').files.length;"></input>
					<input type="text" name="photos" id="hiddenphotobutton" style="display: none;">
					<textarea id="sendbox" class="input" name="text" oninput="if (event.keyCode !== 13) inputKeyDown();" form="sendform" onkeydown="if (event.keyCode === 13 && ! event.shiftKey){event.preventDefault(); sendForm();}"></textarea>
					<input type="text" name="chat" id="hiddenchatbox" form="sendform" style="display: none">
					<button type="button" id="sendbutton" onclick="sendForm();">↑</button>
				</form>
			</div>
			<div class="popup" id="popup">
				<div class="compose" id="compose">
					<form action="send" method="POST" enctype="multipart/form-data" id="composeform" class="composeTextBox" target="dummyframe" name="composeform">
						<div class="composeTitleBoxDiv">
							<button onclick="hidePopup();" id="composeHideButton">Cancel</button>
							<span id="composeTitleBoxTitle">New Message</span>
							<button onclick="sendComposeForm();" id="composeSendButton">Send</button>
						</div>
						<div class="composeAddressBoxDiv">
							<span class="composeAddressToDiv">To:</span>
							<input name="chat" id="composeAddressBox" form="composeform" placeholder="address here (e.g. '+19280372949')">
							<input value="&#128206" onclick="document.getElementById('composeAttachmentButton').click();" type="button" id="composeShowingAttachmentButton"></input>
							<input type="file" name="attachments" id="composeAttachmentButton" multiple onchange="document.getElementById('composeShowingAttachmentButton').value = document.getElementById('composeAttachmentButton').files.length.toString();"></input>
						</div>
						<textarea id="composeSendBox" form="composeform" placeholder="body here"></textarea>
						<textarea name="text" style="display: none;" form="composeform" id="hiddenComposeTextArea"></textarea>
					</form>
				</div>
			</div>
		<div class="camerarollpopup" id="camerarollpopup">
		<div class="cameraroll" id="cameraroll">
			<div id="camerarollTitle">
			<button onclick="hideCameraRoll();" id="camerarollHideButton">Cancel</button>
			<span id="camerarollTitleBoxTitle">Choose Camera Roll Images</span>
			<button onclick="selectCameraRollPhotos();" id="camerarollSelectButton">Select</button>
			</div>
			<div id="camerarollContent">
			<button class="photo" id="morephotosbutton" onclick="loadMoreCameraRoll();">+ More</button>
			</div>
		</div>
		</div>
		</div>
	</body>
</html>
